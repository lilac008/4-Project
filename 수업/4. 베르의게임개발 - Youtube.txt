베르의 게임 개발 유튜브
어소트락
퀴즈
c#
- 

 

1) 설정
window - package manager - All Packages - 2D sprite(유니티 엔진에서 2D 및 UI작업에 도움을 주는 패키지) 설치
2) https://drive.google.com/file/d/1qRe7YEmZFuEbD6-s69ePsgtPkT--jbiy/view
(베르의게임개발유튜브-UI비법서 영상)
링크 다운 후 유니티 엔진에 import 
3) 다운받은 texture를 전부 선택 후 Inspector 영역에서 
Texture Type : Default(3D) -> Sprite(2D and UI)로 변경



[Hierarchy] 
UI - Canvas (모든 image, texture, button은 canvas에 표시된다.)

[Scene]
2D 모드


[Canvas - Image의 properties (inspector 영역)] 
- Source Image : 화면에 보여줄 그림을 설정
- Color : RGBA의 A값은 이미지의 투명도를 결정
- Material : 흐리거나 왜곡되어 보이는 효과
- Raycast Target : 이미지를 raycast에 검출되게 함(클릭한 위치에 빛을 쏘아 빛에 맞은 obj를 검출) 
- Image Type : Simple / Sliced / Tiled / Filled  
Simple : 이미지 그대로 
Sliced : 선택 후 해당된 원본 스프라이트를 inspector영역에서 Sprite Editor로 나눠 리소스를 재사용함으로서 용량을 줄일 수 있다(초록점선으로 이미지를 나눠 특정 부분의 해상도를 유지한채로 이미지를 채운다)
- Fill Center : 중간을 채울지 결정
- Pixcel Per Unit Multipler : sliced된 이미지의 픽셀 크기를 결정 (1이 최대, 작을수록 픽셀크기보다 커진다) 
Tiled : 반복되는 이미지
- Pixcel Per Unit Multipler : 클수록 픽셀 반복 확장  
Filled : 차오르는 게이지 연출
- Fill Method : Radial 360 / Vertical(수직 ex스킬쿨다운) / Horizontal(수평 ex로딩바,경험치바)
- Fill Origin : Top
- Fill Amount : Fill Method/Origin/Clockwise 방법대로 이미지가 채워지는 정도
- Clockwise : 비활성화

##############################
# Fill Amount 사용하기 
(- 아래 script를 ImageType - Filled - (Radial/Vertical/Horizontal)가 적용된 이미지에 각각 연결시켜 확인해보기)

using UnityEngine.UI;

class ImageFiller : 
{

private Image image;
void Start()
{
image = GetComponent<Image>();	//image component 가져오기
}

float timer = 0f;
void Update()
{
timer += Time.deltaTime;
image.fillAmount = Mathf.Sin(timer) * 0.5f + 0.5f;	//image component의 fillAmount값을 시간에 따른 sin그래프 형태로 1~0사이로 왔다갔다하도록
}
}
#########################

#########################
# script로 source image 변경하기
(- ImageFiller 비활성화)

using UnityEngine.UI;


private Image image;	//

[SerializeField]			//sprite 배열은 inspector뷰에서 채워주므로 serializeField 적용
private Sprite[] sprites;	

private int index;


class ImageChanger : 
{

void start()
{
image = GetComponent<Image>();	        //image component 가져오기
}	 

void Update()
{
	if(Input.GetKeyDown(KeyCode.Space))
	{
		image.sprite = sprites[index]; 
		index++;								//index 1씩 증가	
		if(sprites.Length == index)				//sprite가 가진 이미지 수와 index값이 같아지면 (index값이 넘어가면 에러)
		{
			index = 0;
		}
	}
}

}
#########################




Use Sprite Mesh : 이미지 그리는 영역 설정, 활성화시 텍스처 알파영역을 무시하고 최대한 그림에 맞는 형태로 그림.
(* Scene뷰 - Shaded - overdraw에서 확인 : 이미지가 겹쳐지면 리소스를 잡아먹으므로 반드시 필요한 경우가 아니면 피하는 것이 좋다.)
Preserve Aspect : (source image에 맞춰 늘어난 이미지가 아닌) 원래 비율의 형태로 보이도록 설정
 
