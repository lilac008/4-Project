


소켓(SOCKET) 통신   <-> HTTP통신

BSD SOCKET (버클리 소켓)
버클리대에서 C언어로 만들어진  프로그램과 프로그램을 연결하는 도구로 현실에서 가전제품이 소켓으로 연결되어있는 것과 비슷해 소켓이라는 이름이 붙음.
네트워크 프로그램에서 가장 범용적. 


TCP/IP 프로토콜 (220V)  ex) 게임 서버
연결형 소켓. 양방향으로 바이트 스트림을 전송. (한번 연결하면 끊기지 않음. 양방향 통신이 가능함. 한번 끊어지면 절대 연결이 안됨.) 
오류 수정, 청송처리, 흐름제어 보상, 
(데이터 신뢰성, 정확도가 높음)
송신된 순서에 따라 중복되지 않게 데이터를 수신 -> 오버헤드(순서에 따라 중복되지 않도록 프로토콜로 만들어놓음, 프로토콜이 꽉 차면 더 이상 못보내고 대기상태가 됨, ex)파일전송, 유튜브 화상카메라 화면깨짐 = 오버헤드)가 발생
대량의 데이터 전송에 적합 ->(오버헤드 발생시)TCP사용


UDP 프로토콜 (110V)  ex)전화
비연결형 소켓
데이터 크기에 제한
데이터 순서와 상관없이 전송 -> 데이터 유실될 가능성, 확실하게 전달되지 않음 / 손실된 데이터를 진행시키는 프로세스를 따로 처리해야 하므로 상당한 노하우가 필요하며 전문가들은 UDP를 활용한다. 
데이터 손실되도 오류가 발생하지 않음
실시간 멀티미디어 정보를 처리하기 위해 주로 사용 ex전화
User Datagram Protocol(지속적인 데이터 흐름)


UDP 보내기만함  / 초당 60프레임  /  60프레임은 느려서 스레드를 사용해 신호가 들어왔을때 즉각 반응하도록 만듬 / 
TCP는 양방향     / 초당 


--------------------------------------------------------------------------------------------------
TCP/IP
소켓통신 WolkFlow
- 서버용 프로그램                  - 클라이언트 프로그램
sokect()
bind()				socket()
listen()		<-		connect()
accept()		
read()/write()	<->		read()/write()
close()				close()

소켓통신 -> 단점 : 보안을 걸어야 한다. 
1) sokect()을 이용하여 소켓을 생성. 꼽는다. 
2) bind() ip와 port(통신별로 구분)번호를 설정
3) listen() 기다림. 대기상태. 클라이언트 접근 요청에 수신 대기열을 만들어 몇개의 클라이언트를 대기시킬지 결정 
4) accept()를 사용하여 클라이언트와의 연결을 기다림. 받아들임
5) read()/write() 받아서 처리  / read()서버에서 받음, write()서버로 보냄
6) close() 안시키면 포트가 남아있어 반드시 종료시켜야 함

클라이언트
1) socket()  가장먼저 소켓을 open
2) connect() 를 이용하여 통신할 서버의 설정된 ip와 port번호에 통신을 시도 (클라이언트 다운받을시 바이너리 코드로 ip,port번호가 다 보임 보안에 취약 )
3) 통신을 시도시, 서버가 accept()를 이용하여 클라이언트의 socket descriptor를 반환
4) 이를 통해 클라이언트와 서버가 서로 read()/write()를 하며 통신(이 과정이 반복)


--------------------------------------------------------------------------------------------------
UDP서버/클라이언트 구조

UDP서버 				UDP클라이언트      
sokect()				socket()
bind()				connect()	
recvfrom()			send()
sendto()				recv()
closesocket()			closesocket()

방송용.속도빠름.1:1통신 필요없고 그냥 자기 네트워크에 방송보냄.


receiver, send, 


packet(데이터구조)  X Y Z Count 


--------------------------------------------------------------------------------------------------

TCP는 양방향 통신, 
데이터가 제대로 된 것이 아니면 requset, resend 요구
세크먼트
연결형
송신순서와 일치
오류제어,흐름제어
느림

UDP는 일방향, 받든 말든 그냥 보냄 
블록 단위로 보냄
비연결형
송신 순서와 불일치
오류제어,흐름제어 X
빠름

--------------------------------------------------------------------------------------------------

Process 

code		data		heap

thread1		thread2		thread3
stack		stack		stack


thread를 사용에 소켓 통신을 구현


*참조
/// code  (실행 중 유지, 수정x)    :  text 영역 (상수, code들, method, class 그 자체)  / class
/// data  (실행 중 유지)             :  global 변수, static 변수 
정적

/// heap   (계속 변화)               :  동적(dynamic), reference형                           /  new ClassName()의 본체
클래스 생성
       |
/// stack (계속 변화, 휘발성)       :  local 변수, parameter(매개변수), value형             /  new ClassName()의 instance 객체 
함수 생성 후 휘발
- 휘발성이므로 메모리 소모가 없음(다고 봐야함), stack(구조체?)이라는 구조에 데이터를 집어넣었다 뺐다함
--------------------------------------------------------------------------------------------------
127.0.0.1 의미 - 윈도우에서 사용하는 모든 컴퓨터 IP
cmd에서 ipconfig 치면 IP주소가 뜬다. 



아이피 : 데이터 통로(데이터 통로 주소)로 아이피를 관리하는 서버가 따로 있음, 우리가 사용하는 아이피는 고정이 아니라 사설로, 속도가 느려터진 인터넷개념
 	고정아이피는 따로 관리하고 있음, 아이피를 할당받으면 유선전화를 하나 받은 것과 똑같다. 
	게임업체들은 고정 아이피를 쓴다. 1급 아이피주소는 클라이언트에서 아이피로 바로 올라가버린다. 네이버나 대형포탈은 최상위 속도가 매우 빠름
           
포트 : 아이피 내에서 애플리케이션 상호 구분(프로세스 구분)을 위해 사용하는 번호 
포트 숫자는 IP주소가 가리키는 PC에 접속할 수 있는 통로(채널)을 의미한다. 

IP(Internet Protocol Address) : 네트워크에 연결된 특정 PC를 가르키는 주소, 
Port : 그 주소에 진입할 수 있는 정해진 통로 


--------------------------------------------------------------------------------------------------


유니코드
아스키 코드 문자,숫자 바이트
랜카드  주소 IP 어떤 컴퓨터에서 사용했는지 시간까지 알 수 있다. 


TCP/IP
//서버가 먼저 실행된 상태에서 클라이언트를 실행해야함
서버가 1이면 클라이언트는 1이될수도 100이될 수도 있어서 
1:1이지만 서버가 먼저 열려야 한다.

>프로트콜 주소는 하나만 입력해야한다 오류 > 스크립트 destroy함수 추가 > 껐다켜서 확인 > 

서버에서 게임화면에서 클릭하면 Debug.log로 하이서버 ~~
클라이언트에서 게임화면에서 클릭하면 Debug.log로 하이 클라이언트~~



UDP send receiver 
데이터를 일방적으로 보내기 때문에 그럴 필요가 없음


