https://mangkyu.tistory.com/15
https://evan-moon.github.io/2019/11/22/tcp-flow-control-error-control/
https://codedragon.tistory.com/4092?category=82522
https://dinfree.com/lecture/core/101_basic_2.html
https://mangkyu.tistory.com/15

https://mangkyu.tistory.com/15
https://mangkyu.tistory.com/48?category=762469

1. Socket과 Stream

A  --socket-----------> B
   <-----------socket-- 

1) Network Socket (네트워크 소켓) 
- 네트워크 통신을 위해 데이터를 교환하는 곳으로 이 socket을 통해 서로 응답(데이터를 교환하기로 합의)하며 보내고자 하는 IP주소, port 주소를 명시한다. (IP주소 : 전화번호, port 번호 : 교환번호)
- 오늘날 컴퓨터 통신의 대부분은 인터넷 프로토콜(Internet Protocol, IP)을 기반으로 하고 있으므로, 대부분의 네트워크 소켓은 인터넷 소켓이다. 

BSD SOCKET (버클리 소켓)
버클리대에서 C언어를 기반으로 만들어진 프로그램과 프로그램을 연결하는 도구. 네트워크 프로그램에서 가장 범용적. 

2) Stream (스트림)
파일을 읽거나 쓸 때, 네트워크 소켓을 거쳐 통신할 때 쓰이는 추상적인 개념.


소켓(Socket) 프로그래밍
- TCP/IP 프로토콜을 기반으로 맺어진 네트워크 연결 방식
- Server와 Client가 특정 Port를 통해 연결을 유지하며 실시간으로 양방향으로 통신
- Http 프로그래밍과 달리 Socket 프로그래밍은 Server 역시 Client로 요청을 보낼 수 있으며, 
계속 연결을 유지하는 연결지향형 방식이기 때문에 실시간 통신이 필요한 경우에 자주 사용
실시간 Streaming 중계나 실시간 채팅과 같이 즉각적으로 정보를 주고받는 경우에 사용합니다. 예를 들어 실시간 동영상 Streaming 서비스를 Http 프로그래밍으로 구현하였다고 가정하겠습니다. 이러한 경우에 사용자가 서버로 동영상을 요청하기 위해서는 동영상이 종료되는 순간까지 계속해서 Http Request를 보내야 하고 이러한 구조는 계속 연결을 요청하기 때문에 부하가 걸리게 됩니다.


--------------------------------------------------------------------------------------------------
2. 
Protocol 
: 컴퓨터 간에 data를 주고 받기 위한 일련의 통신 규약

Protocol의 종류 
- TCP   (Transmission Control Protocol) 
- IP      (Internet Protocol, 아이피)
- HTTP  (HyperText Transfer Protocol) : Client의 요청(Request)이 있을 때만 서버가 응답(Response)하여 해당 정보를 전송하고 곧바로 연결을 종료하는 방식
- SMTP (Simple Mail Transfer Protocol)
- FTP    (File Transfer Protocol)
- 각 protocol에서 작용하는 socket이 다르다. 


TCP (Transmission Control Protocol) / IP (Internet Protocol)
1) TCP (Transmission Control Protocol)
ex) 군사 및 연구 목적 -> 인터넷(World Wide Web), 게임서버
- 연결형 socket.  가상회선(발신지와 수신지를 연결하여 패킷(*data를 packet단위로 나누어 전송)을 전송하기 위한 논리적 경로를 배정) 방식 제공
- 양방향 통신이 가능한 socket. 한번 연결하면 끊기지 않음. 한번 끊어지면 절대 연결이 안됨. 
- 패킷을 조절하는 흐름 제어, 오류 제어 -> 데이터 신뢰성, 정확도 높으나 UDP에 비해 속도가 느림
- 송신된 순서에 따라 중복되지 않게 데이터 수신 -> 오버헤드(처리하는데 들어가는 시간, 메모리 초과된 것) 발생, (순서에 따라 중복되지 않도록 protocol로 만들어놓고 protocol이 꽉 차면 더 이상 못 보내고 대기상태가 됨, ex) 유튜브 화상카메라 화면깨짐 / 오버헤드 = 대기상태 = 화면깨짐) 
- 데이터 크기 무제한
- client와 서버는 1:1로 연결

2) IP (Internet Protocol)
- 비신뢰성(unreliability) :  IP 프로토콜이 전송하는 데이터가 정확하게 갔는지 확인하지 않음
- 비연결성(connectionlessness) : 데이터 전송 이전에 미리 설정과정을 거치지 않음 
- 패킷 전송과 정확한 순서를 보장하려면 TCP 프로토콜과 같은 IP의 상위 프로토콜을 이용해야 한다.

UDP (User Datagram Protocol)
- 비연결형 소켓. 
- 일방향 통신(보내기만함, 초당 60프레임은 느린 편이므로 스레드를 사용해 신호가 들어왔을때 즉각 반응하도록 만듬), 
데이터 유실 가능성, 데이터 손실되어도 오류가 발생하지 않음
 ->  손실된 데이터를 진행시키는 프로세스를 따로 처리해야 하므로 상당한 노하우가 필요하며 전문가들은 UDP를 활용한다. 
- 데이터 순서와 상관없이 전송, 정보를 노내거나 받는다는 신호절차를 거치지 않음 -> 신뢰성이 낮음
- 데이터 크기에 제한
- 실시간 멀티미디어 정보를 처리하기 위해 주로 사용 ex전화


TCP/IP 프로토콜 (220V)					UDP 프로토콜 (110V)     
ex) 게임 서버						ex) 전화   
연결형 소켓						비연결형 소켓
양방향 통신 						일방향 통신(보내기만함)
송신된 순서에따라 중복되지 않게 수신,데이터 신뢰성, 정확도 높음	순서와 상관없이 전송, 데이터 손실 가능성, 손실되어도 오류는 발생하지 않음 
대량의데이터전송						데이터크기제한


* packet(TCP), datagram(UDP)
- data 조각들. data와 호 제어 신호가 포함된 2진수 비트 그룹.  
- data를 packet 단위로 분해하여 전송한 후 다시 원래의 data로 재조립하여 처리.

--------------------------------------------------------------------------------------------------
TCP/IP
소켓통신 WolkFlow
- 서버용 프로그램                  - 클라이언트 프로그램
sokect()
bind()				socket()
listen()		<-		connect()
accept()		
read()/write()	<->		read()/write()
close()				close()

소켓통신 -> 단점 : 보안을 걸어야 한다. 
1) sokect()을 이용하여 소켓을 생성. 꼽는다. 
2) bind() ip와 port(통신별로 구분)번호를 설정
3) listen() 기다림. 대기상태. 클라이언트 접근 요청에 수신 대기열을 만들어 몇개의 클라이언트를 대기시킬지 결정 
4) accept()를 사용하여 클라이언트와의 연결을 기다림. 받아들임
5) read()/write() 받아서 처리  / read()서버에서 받음, write()서버로 보냄
6) close() 안시키면 포트가 남아있어 반드시 종료시켜야 함

클라이언트
1) socket()  가장먼저 소켓을 open
2) connect() 를 이용하여 통신할 서버의 설정된 ip와 port번호에 통신을 시도 (클라이언트 다운받을시 바이너리 코드로 ip,port번호가 다 보임 보안에 취약 )
3) 통신을 시도시, 서버가 accept()를 이용하여 클라이언트의 socket descriptor를 반환
4) 이를 통해 클라이언트와 서버가 서로 read()/write()를 하며 통신(이 과정이 반복)


--------------------------------------------------------------------------------------------------
UDP서버/클라이언트 구조

UDP서버 				UDP클라이언트      
sokect()				socket()
bind()				connect()	
recvfrom()			send()
sendto()				recv()
closesocket()			closesocket()

방송용.속도빠름.1:1통신 필요없고 그냥 자기 네트워크에 방송보냄.


receiver, send, 


packet(데이터구조)  X Y Z Count 


--------------------------------------------------------------------------------------------------

TCP는 양방향 통신, 
데이터가 제대로 된 것이 아니면 requset, resend 요구
세크먼트
연결형
송신순서와 일치
오류제어,흐름제어
느림

UDP는 일방향, 받든 말든 그냥 보냄 
블록 단위로 보냄
비연결형
송신 순서와 불일치
오류제어,흐름제어 X
빠름

--------------------------------------------------------------------------------------------------

Process 

code		data		heap

thread1		thread2		thread3
stack		stack		stack


thread를 사용에 소켓 통신을 구현


*참조
/// code  (실행 중 유지, 수정x)    :  text 영역 (상수, code들, method, class 그 자체)  / class
/// data  (실행 중 유지)             :  global 변수, static 변수 
정적

/// heap   (계속 변화)               :  동적(dynamic), reference형                           /  new ClassName()의 본체
클래스 생성
       |
/// stack (계속 변화, 휘발성)       :  local 변수, parameter(매개변수), value형             /  new ClassName()의 instance 객체 
함수 생성 후 휘발
- 휘발성이므로 메모리 소모가 없음(다고 봐야함), stack(구조체?)이라는 구조에 데이터를 집어넣었다 뺐다함
--------------------------------------------------------------------------------------------------
127.0.0.1 의미 - 윈도우에서 사용하는 모든 컴퓨터 IP
cmd에서 ipconfig 치면 IP주소가 뜬다. 



아이피 : 데이터 통로(데이터 통로 주소)로 아이피를 관리하는 서버가 따로 있음, 우리가 사용하는 아이피는 고정이 아니라 사설로, 속도가 느려터진 인터넷개념
 	고정아이피는 따로 관리하고 있음, 아이피를 할당받으면 유선전화를 하나 받은 것과 똑같다. 
	게임업체들은 고정 아이피를 쓴다. 1급 아이피주소는 클라이언트에서 아이피로 바로 올라가버린다. 네이버나 대형포탈은 최상위 속도가 매우 빠름
           
포트 : 아이피 내에서 애플리케이션 상호 구분(프로세스 구분)을 위해 사용하는 번호 
포트 숫자는 IP주소가 가리키는 PC에 접속할 수 있는 통로(채널)을 의미한다. 

IP(Internet Protocol Address) : 네트워크에 연결된 특정 PC를 가르키는 주소, 
Port : 그 주소에 진입할 수 있는 정해진 통로 


--------------------------------------------------------------------------------------------------


유니코드
아스키 코드 문자,숫자 바이트
랜카드  주소 IP 어떤 컴퓨터에서 사용했는지 시간까지 알 수 있다. 


TCP/IP
//서버가 먼저 실행된 상태에서 클라이언트를 실행해야함
서버가 1이면 클라이언트는 1이될수도 100이될 수도 있어서 
1:1이지만 서버가 먼저 열려야 한다.

>프로트콜 주소는 하나만 입력해야한다 오류 > 스크립트 destroy함수 추가 > 껐다켜서 확인 > 

서버에서 게임화면에서 클릭하면 Debug.log로 하이서버 ~~
클라이언트에서 게임화면에서 클릭하면 Debug.log로 하이 클라이언트~~



UDP send receiver 
데이터를 일방적으로 보내기 때문에 그럴 필요가 없음


